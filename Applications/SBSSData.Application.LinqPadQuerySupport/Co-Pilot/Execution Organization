Execution Organization

The Web page is created using a LINQPad query (required because table rendering difference between the LinqPadRuntime.dll for LINQPad8 and nuget package for C#).

For example, for the GamesTeamPlayersV3 page, 
void Main()
{
    string seasonText = "2024 Winter";
    string dsFolder = $@"J:\SBSSDataStore\";
        
    GamesTeamPlayersV3 gtp = new GamesTeamPlayersV3();
    string html = gtp.BuildHtmlPage(seasonText, dsFolder, callback);
    
    string folderName = @$"{dsFolder}Html Data\";
    string fileName = "GamesTeamPlayersV3.html";
    string htmlFilePath = $"{folderName}{fileName}";

    File.WriteAllText(htmlFilePath, html);
    Process.Start(@"C:\Program Files (x86)\Microsoft\Edge Dev\Application\msedge.exe", $"\"{htmlFilePath}\"");
}
public static Action<object> callback = (v) => v.Dump(collapseTo: 1);

It uses the GamesTeamPlayersV3 class to actually the html, which is the BuildHtmlPage method. It does the following:
(1) Recovers the introductory information from a HTML file that is an embedded resource -- this html is placed immediately after the body tag of the final page. More stuff can be there depending the rest of the processing
(2) A DataStoreContainer is created and Query class which is used to get the and
organized the table(s) data
(3) An HtmlGenerator is created and the results from the query and any other information is written to the html generator. Tables use the WriteRootTable method and specify a callback to gains control as the html is generator
(4) The last is to invoke generator.DumpHtml which has parameters (for example, local styles and head elements) to further modify the html generated by generator.Write classes. It returns the final html which is saved (and displayed) by the LINQPad query.

Because the HTML is not written until DumpHtml, it is the callback(2) that can do all the fine tuning styling and other work. Right now, that seems spread around too much, so we need organize the scripting and styling so that it can be put in the page by DumpHtml rather than by callbacks. It is key that DumpHtml sets the stage independing of the tables that are generated. For examples, here's the call to the DumpHtml method the returns the page Html for GamesTeamPlayersV3 class:

changedHtml = generator.DumpHtml(pageTitle: title,
                                 cssStyles: StaticConstants.LocalStyles,
                                 collapseTo: 1,
                                 headElements: headElements.ToList());

It does the following (at least now) using parameters passed to it.
(0) Creates and HtmlDocument from the generator writer that can be parsed using HtmlAgilityPack API.
(1) Adds head meta and link tags to the page
(2) Adds "local styles" to the style element in page head
(3) Inserts a page title right after the body tag
(4) Other tasks that should be done for all tables, for example, right justifying number cells and modifying columns so that they appear as titles (e.g., BuildData because Build Data)
(5) Because there can be many and deeply nested tables, somehow how they need to be identified. Because the document is available, all tables are found and identified by their depth and index at the depth. In fact a tree of all tables is created and each table node has an associated depth and index (using the TableNode class)
(5a) VERY IMPORTANT. For every root table (no table ancestors), a callback is specified (which may be null), when the WriteRootTable method in the generator is called. For these root tables, the TableTree is created, and then the  TableTree.SetTableHeader method is calld passing the root table and the associated callback. The callback is Func<TableNode, string> delegate and the returned sets the header for all tables in tree. It responsibility of the call back change sub tables header approriately.
(6) Again using a collapseTo parameter all tables whose depth or equal are collapsed.
(7) The table tfoot element is removed
(8) The TableTree depth and index of a table is recorded as attributes in the span element of the table header.

The final chance for modify in tables and HTML is in the call backs. And that is where much of the changes are made. The callback can be very simple, for example, (t) => "This is a header", or very complicated.

SUMMARY
LINQPad query invokes a BuildHtml method on an asociated class.
The BuildHtml method using Query properties to build the table data and writes that information to the generator (specifying a callback if needed) and then calls DumpHtml on the generator the return the page html. The DumpHtml method modifies modifies the page based on parameters, build a TableTree for each root table and invokes the TableTree.SetTableHeader method passing the callback for that table.